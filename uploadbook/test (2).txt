How to do it… Write the code we want to use indented in the try block:1.
        try:            shutil.copy( str(source_file_path), str(target_file_path) ) Include the most specific exception classes first. In this case, we have separate2. responses for the specific FileNotFoundError and the more general OSError.
        try:            shutil.copy( str(source_file_path), str(target_file_path) )        except FileNotFoundError:            os.makedir( target_file_path.parent )            shutil.copy( str(source_file_path), str(target_file_path) ) Include any more general exceptions later:3.
        try:            shutil.copy( str(source_file_path), str(target_file_path) )        except FileNotFoundError:            os.makedirs( str(target_file_path.parent) )            shutil.copy( str(source_file_path), str(target_file_path) )        except OSError as ex:            print(ex) We've matched exceptions with the most specific first and the more generic after that. We handled the FileNotFoundError by creating the missing directories. Then we did the copy() again, knowing it would now work properly. We silenced any other exceptions of the class OSError. For example, if there's a permission problem, that error will simply be logged. Our objective is to try and copy all of the files. Any files that cause problems will be logged, but the copying process will continue.
Statements and Syntax
[ 100 ]
How it works… Python's matching rules for exceptions are intended to be simple: Process the except clauses in order Match the actual exception against the exception class (or tuple of exception classes). A match means that the actual exception object (or any of the base classes of the exception object) is of the given class in the except clause.
These rules show why we put the most specific exception classes first and the more general exception classes last. A generic exception class like the Exception will match almost every kind of exception. We don't want this first, because no other clauses will be checked. We must always put generic exceptions last. There's an even more generic class, the BaseException class. There's no good reason to ever handle exceptions of this class. If we do, we will be catching SystemExit and KeyboardInterrupt exceptions, which interferes with the ability to kill a misbehaving application. We only use the BaseException class as a superclass when defining new exception classes that exist outside the normal exception hierarchy.
There's more… Our example includes a nested context in which a second exception can be raised. Consider this except clause:
    except FileNotFoundError:        os.makedirs( str(target_file_path.parent) )        shutil.copy( str(source_file_path), str(target_file_path) ) If the os.makedirs() or shutil.copy() functions raise another exception, it won't be handled by this try statement. Any exceptions raised here will crash the program as a whole. We have two ways to handle this, both of which involve nested try statements. We can rewrite this to include a nested try during recovery:
    try:        shutil.copy( str(source_file_path), str(target_file_path) )    except FileNotFoundError:        try:            os.makedirs( str(target_file_path.parent) )            shutil.copy( str(source_file_path), str(target_file_path) )        except OSError as ex:            print(ex)